============================= test session starts ==============================
platform darwin -- Python 3.10.1, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/env/bin/python3
cachedir: .pytest_cache
rootdir: /Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside
plugins: mock-3.7.0
collecting ... collected 48 items

tests/test_accounts_public.py::test_accounts_create FAILED               [  2%]
tests/test_accounts_public.py::test_accounts_edit FAILED                 [  4%]
tests/test_accounts_public.py::test_accounts_password PASSED             [  6%]
tests/test_accounts_public.py::test_accounts_delete FAILED               [  8%]
tests/test_accounts_public.py::test_accounts_uploads_permission FAILED   [ 10%]
tests/test_database_public.py::test_sql_schema PASSED                    [ 12%]
tests/test_database_public.py::test_likeids PASSED                       [ 14%]
tests/test_database_public.py::test_posts_autoincrement PASSED           [ 16%]
tests/test_database_public.py::test_sql_data_users_posts PASSED          [ 18%]
tests/test_explore.py::test_awdeorio_default FAILED                      [ 20%]
tests/test_explore.py::test_follow FAILED                                [ 22%]
tests/test_explore.py::test_empty FAILED                                 [ 25%]
tests/test_followers_public.py::test_awdeorio_followers FAILED           [ 27%]
tests/test_followers_public.py::test_files FAILED                        [ 29%]
tests/test_followers_public.py::test_unfollow FAILED                     [ 31%]
tests/test_followers_public.py::test_follow FAILED                       [ 33%]
tests/test_following.py::test_awdeorio FAILED                            [ 35%]
tests/test_following.py::test_unfollow FAILED                            [ 37%]
tests/test_following.py::test_not_following PASSED                       [ 39%]
tests/test_index.py::test_images FAILED                                  [ 41%]
tests/test_index.py::test_links PASSED                                   [ 43%]
tests/test_index.py::test_likes PASSED                                   [ 45%]
tests/test_index.py::test_timestamps PASSED                              [ 47%]
tests/test_index.py::test_comments PASSED                                [ 50%]
tests/test_login_logout.py::test_index_redirect PASSED                   [ 52%]
tests/test_login_logout.py::test_login_page_content FAILED               [ 54%]
tests/test_login_logout.py::test_login PASSED                            [ 56%]
tests/test_login_logout.py::test_logout PASSED                           [ 58%]
tests/test_post_public.py::test_postid_1 FAILED                          [ 60%]
tests/test_post_public.py::test_postid_2 FAILED                          [ 62%]
tests/test_post_public.py::test_zero_likes_english PASSED                [ 64%]
tests/test_post_public.py::test_delete_comment PASSED                    [ 66%]
tests/test_post_public.py::test_like_unlike PASSED                       [ 68%]
tests/test_post_public.py::test_duplicate_like_unlike FAILED             [ 70%]
tests/test_post_public.py::test_comment PASSED                           [ 72%]
tests/test_post_public.py::test_delete_post FAILED                       [ 75%]
tests/test_scripts.py::test_insta485db_destroy PASSED                    [ 77%]
tests/test_scripts.py::test_insta485db_create PASSED                     [ 79%]
tests/test_scripts.py::test_insta485db_reset PASSED                      [ 81%]
tests/test_scripts.py::test_insta485db_dump PASSED                       [ 83%]
tests/test_scripts.py::test_insta485run PASSED                           [ 85%]
tests/test_scripts.py::test_insta485test PASSED                          [ 87%]
tests/test_style.py::test_pycodestyle FAILED                             [ 89%]
tests/test_style.py::test_pydocstyle FAILED                              [ 91%]
tests/test_style.py::test_pylint FAILED                                  [ 93%]
tests/test_style.py::test_html FAILED                                    [ 95%]
tests/test_user_public.py::test_awdeorio FAILED                          [ 97%]
tests/test_user_public.py::test_upload FAILED                            [100%]

=================================== FAILURES ===================================
_____________________________ test_accounts_create _____________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_accounts_create(client):
        """Create an account and verify that we've got a new empty user.
    
        Note: 'client' is a fixture fuction that provides a Flask test server
        interface with a clean database.  It is implemented in conftest.py and
        reused by many tests.  Docs: https://docs.pytest.org/en/latest/fixture.html
        """
        # Connect to the database
        connection = sqlite3.connect("var/insta485.sqlite3")
        connection.execute("PRAGMA foreign_keys = ON")
    
        # Number of posts and users before adding a user
        cur = connection.execute("SELECT COUNT(*) from users")
        num_users_before = cur.fetchone()[0]
        cur = connection.execute("SELECT COUNT(*) from posts")
        num_posts_before = cur.fetchone()[0]
    
        # Add a user
        avatar_path = utils.TEST_DIR/"testdata/fox.jpg"
        with avatar_path.open('rb') as avatar:
            query_string = urlencode({"target": "/"})
>           response = client.post(
                f"/accounts/?{query_string}",
                data={
                    "username": "fakeuser", "fullname": "Fake User",
                    "email": "fakeuser@umich.edu",
                    "password": "password",
                    "file": avatar,
                    "operation": "create"
                }
            )

tests/test_accounts_public.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.10/site-packages/werkzeug/test.py:1134: in post
    return self.open(*args, **kw)
env/lib/python3.10/site-packages/flask/testing.py:216: in open
    return super().open(  # type: ignore
env/lib/python3.10/site-packages/werkzeug/test.py:1074: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:945: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:1231: in run_wsgi_app
    app_rv = app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2091: in __call__
    return self.wsgi_app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2076: in wsgi_app
    response = self.handle_exception(e)
env/lib/python3.10/site-packages/flask/app.py:2073: in wsgi_app
    response = self.full_dispatch_request()
env/lib/python3.10/site-packages/flask/app.py:1519: in full_dispatch_request
    return self.finalize_request(rv)
env/lib/python3.10/site-packages/flask/app.py:1538: in finalize_request
    response = self.make_response(rv)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'insta485'>, rv = None

    def make_response(self, rv: ResponseReturnValue) -> Response:
        """Convert the return value from a view function to an instance of
        :attr:`response_class`.
    
        :param rv: the return value from the view function. The view function
            must return a response. Returning ``None``, or the view ending
            without returning, is not allowed. The following types are allowed
            for ``view_rv``:
    
            ``str``
                A response object is created with the string encoded to UTF-8
                as the body.
    
            ``bytes``
                A response object is created with the bytes as the body.
    
            ``dict``
                A dictionary that will be jsonify'd before being returned.
    
            ``tuple``
                Either ``(body, status, headers)``, ``(body, status)``, or
                ``(body, headers)``, where ``body`` is any of the other types
                allowed here, ``status`` is a string or an integer, and
                ``headers`` is a dictionary or a list of ``(key, value)``
                tuples. If ``body`` is a :attr:`response_class` instance,
                ``status`` overwrites the exiting value and ``headers`` are
                extended.
    
            :attr:`response_class`
                The object is returned unchanged.
    
            other :class:`~werkzeug.wrappers.Response` class
                The object is coerced to :attr:`response_class`.
    
            :func:`callable`
                The function is called as a WSGI application. The result is
                used to create a response object.
    
        .. versionchanged:: 0.9
           Previously a tuple was interpreted as the arguments for the
           response object.
        """
    
        status = headers = None
    
        # unpack tuple returns
        if isinstance(rv, tuple):
            len_rv = len(rv)
    
            # a 3-tuple is unpacked directly
            if len_rv == 3:
                rv, status, headers = rv
            # decide if a 2-tuple has status or headers
            elif len_rv == 2:
                if isinstance(rv[1], (Headers, dict, tuple, list)):
                    rv, headers = rv
                else:
                    rv, status = rv
            # other sized tuples are not allowed
            else:
                raise TypeError(
                    "The view function did not return a valid response tuple."
                    " The tuple must have the form (body, status, headers),"
                    " (body, status), or (body, headers)."
                )
    
        # the body must not be None
        if rv is None:
>           raise TypeError(
                f"The view function for {request.endpoint!r} did not"
                " return a valid response. The function either returned"
                " None or ended without a return statement."
            )
E           TypeError: The view function for 'handle_account' did not return a valid response. The function either returned None or ended without a return statement.

env/lib/python3.10/site-packages/flask/app.py:1701: TypeError
----------------------------- Captured stdout call -----------------------------
create
______________________________ test_accounts_edit ______________________________

client = <FlaskClient <Flask 'insta485'>>
mocker = <pytest_mock.plugin.MockerFixture object at 0x10a743f70>

    def test_accounts_edit(client, mocker):
        """Change name, email and photo.
    
        Note: 'client' is a fixture fuction that provides a Flask test server
        interface with a clean database.  It is implemented in conftest.py and
        reused by many tests.  Docs: https://docs.pytest.org/en/latest/fixture.html
    
        Note: 'mocker' is a fixture function provided the the pytest-mock package.
        This fixture lets us override a library function with a temporary fake
        function that returns a hardcoded value while testing.
        """
        # Fake the uuid4() function to return a hardcoded UUID.  We need a
        # predictable value for testing, not a randomly generated value.
        mocker.patch(
            "uuid.uuid4",
            return_value=uuid.UUID("00000000000000000000000000000000"),
        )
    
        # Log in
        response = client.post(
            "/accounts/",
            data={"username": "awdeorio",
                  "password": "password",
                  "operation": "login"},
        )
        assert response.status_code == 302
    
        # Change name, email and photo
        avatar_path = utils.TEST_DIR/"testdata/fox.jpg"
        with avatar_path.open('rb') as avatar:
            query_string = urlencode({"target": "/accounts/edit/"})
            response = client.post(
                f"/accounts/?{query_string}",
                data={
                    "fullname": "New Name",
                    "email": "newemail@umich.edu",
                    "file": avatar,
                    "update": "submit",
                    "operation": "edit_account"
                },
            )
    
        assert response.status_code == 302
        urlpath = urlparse(response.location).path
        assert urlpath == "/accounts/edit/"
    
        # HACK: Work around to ensure database commit.  The post request above
        # modifies the database.  The modification won't be written until the
        # sqlite3 commit() function is called.  The commit() function is called by
        # model.py::close_db().  The close_db() function runs automatically at the
        # end of a request.  For testing, we temporarily keep the last request
        # open.  This allows us to do things like inspecting the request object.
        # However, in this test, the temporarily open request prevents the database
        # from being written out.
        #
        # The work around is to make a dummy request, which causes the previous
        # request to close and commit() is called automatically.
        #
        # Flask docs:
        # https://flask.palletsprojects.com/en/1.1.x/reqcontext/#teardown-callbacks
        response = client.get("/")
        assert response.status_code == 200
    
        # Look up new users in the database
        connection = sqlite3.connect("var/insta485.sqlite3")
        connection.execute("PRAGMA foreign_keys = ON")
        cur = connection.execute(
            "SELECT username, fullname, email, filename "
            "FROM users WHERE username='awdeorio'"
        )
        users = cur.fetchall()
    
        # Verify new database entry
>       assert users == [(
            "awdeorio",
            "New Name",
            "newemail@umich.edu",
            "00000000000000000000000000000000.jpg",
        )]
E       AssertionError: assert [('awdeorio',\n  'New Name',\n  'newemail@umich.edu',\n  'e1a7c5c32973862ee15173b0259e3efdb6a391af.jpg')] == [('awdeorio',\n  'New Name',\n  'newemail@umich.edu',\n  '00000000000000000000000000000000.jpg')]
E         At index 0 diff: ('awdeorio', 'New Name', 'newemail@umich.edu', 'e1a7c5c32973862ee15173b0259e3efdb6a391af.jpg') != ('awdeorio', 'New Name', 'newemail@umich.edu', '00000000000000000000000000000000.jpg')
E         Full diff:
E           [
E            ('awdeorio',
E             'New Name',
E             'newemail@umich.edu',
E         -   '00000000000000000000000000000000.jpg'),
E         +   'e1a7c5c32973862ee15173b0259e3efdb6a391af.jpg'),
E           ]

tests/test_accounts_public.py:151: AssertionError
_____________________________ test_accounts_delete _____________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_accounts_delete(client):
        """Delete account and verify that everything is gone.
    
        Note: 'client' is a fixture fuction that provides a Flask test server
        interface with a clean database.  It is implemented in conftest.py and
        reused by many tests.  Docs: https://docs.pytest.org/en/latest/fixture.html
        """
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Delete account
        query_string = urlencode({"target": "/accounts/create/"})
        response = client.post(
            f"/accounts/?{query_string}",
            data={
                "delete": "confirm delete account",
                "operation": "delete"
            }
        )
        assert response.status_code == 302
        urlpath = urlparse(response.location).path
        assert urlpath == "/accounts/create/"
    
        # User can no longer access post 1, should be redirected to login
>       response = client.get("/posts/1/")

tests/test_accounts_public.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.10/site-packages/werkzeug/test.py:1129: in get
    return self.open(*args, **kw)
env/lib/python3.10/site-packages/flask/testing.py:216: in open
    return super().open(  # type: ignore
env/lib/python3.10/site-packages/werkzeug/test.py:1074: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:945: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:1231: in run_wsgi_app
    app_rv = app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2091: in __call__
    return self.wsgi_app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2076: in wsgi_app
    response = self.handle_exception(e)
env/lib/python3.10/site-packages/flask/app.py:2073: in wsgi_app
    response = self.full_dispatch_request()
env/lib/python3.10/site-packages/flask/app.py:1518: in full_dispatch_request
    rv = self.handle_user_exception(e)
env/lib/python3.10/site-packages/flask/app.py:1516: in full_dispatch_request
    rv = self.dispatch_request()
env/lib/python3.10/site-packages/flask/app.py:1502: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
insta485/views/index.py:362: in show_post
    logname = flask.session['logname']
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <SecureCookieSession {}>, key = 'logname'

    def __getitem__(self, key: str) -> t.Any:
        self.accessed = True
>       return super().__getitem__(key)
E       KeyError: 'logname'

env/lib/python3.10/site-packages/flask/sessions.py:79: KeyError
_______________________ test_accounts_uploads_permission _______________________

client = <FlaskClient <Flask 'insta485'>>

    def test_accounts_uploads_permission(client):
        """Verify that only authenticated users can see uploads.
    
        Note: 'client' is a fixture fuction that provides a Flask test server
        interface with a clean database.  It is implemented in conftest.py and
        reused by many tests.  Docs: https://docs.pytest.org/en/latest/fixture.html
        """
        response = client.get(
            "/uploads/122a7d27ca1d7420a1072f695d9290fad4501a41.jpg"
        )
>       assert response.status_code == 403
E       assert 404 == 403
E         +404
E         -403

tests/test_accounts_public.py:310: AssertionError
____________________________ test_awdeorio_default _____________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_awdeorio_default(client):
        """Verify default content at /explore/ with awdeorio logged in."""
        # Login
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse explore page
        response = client.get("/explore/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        srcs = [x.get("src") for x in soup.find_all('img')]
        links = [x.get("href") for x in soup.find_all("a")]
        buttons = [submit.get("name") for button in soup.find_all('form')
                   for submit in button.find_all("input") if submit]
    
        # Verify links in header
        assert "/" in links
        assert "/explore/" in links
        assert "/users/awdeorio/" in links
    
        # Verify links specific to /explore/
        assert "/users/jag/" in links
        assert "/users/jflinn/" not in links
        assert "/users/michjc/" not in links
    
        # Verify images
>       assert "/uploads/73ab33bd357c3fd42292487b825880958c595655.jpg" in srcs
E       AssertionError: assert '/uploads/73ab33bd357c3fd42292487b825880958c595655.jpg' in ['/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/73ab33bd357c3fd42292487b825880958c595655.jpg']

tests/test_explore.py:47: AssertionError
_________________________________ test_follow __________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_follow(client):
        """Click follow, then check /users/<user_url_slug>/following/ ."""
        # Login
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        query_string = urlencode({
                "target": "/users/awdeorio/followers/"
            })
>       response = client.post(
            f"/following/?{query_string}",
            data={"operation": "follow", "username": "jag"}
        )

tests/test_explore.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.10/site-packages/werkzeug/test.py:1134: in post
    return self.open(*args, **kw)
env/lib/python3.10/site-packages/flask/testing.py:216: in open
    return super().open(  # type: ignore
env/lib/python3.10/site-packages/werkzeug/test.py:1074: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:945: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:1231: in run_wsgi_app
    app_rv = app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2091: in __call__
    return self.wsgi_app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2076: in wsgi_app
    response = self.handle_exception(e)
env/lib/python3.10/site-packages/flask/app.py:2073: in wsgi_app
    response = self.full_dispatch_request()
env/lib/python3.10/site-packages/flask/app.py:1518: in full_dispatch_request
    rv = self.handle_user_exception(e)
env/lib/python3.10/site-packages/flask/app.py:1516: in full_dispatch_request
    rv = self.dispatch_request()
env/lib/python3.10/site-packages/flask/app.py:1502: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
insta485/views/index.py:467: in follow_unfollow
    logname = flask.session['username']
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <SecureCookieSession {'logname': 'awdeorio'}>, key = 'username'

    def __getitem__(self, key: str) -> t.Any:
        self.accessed = True
>       return super().__getitem__(key)
E       KeyError: 'username'

env/lib/python3.10/site-packages/flask/sessions.py:79: KeyError
__________________________________ test_empty __________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_empty(client):
        """Nobody shows up when you're following everyone."""
        # Login
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Follow jag
        query_string = urlencode({
                "target": "/users/awdeorio/followers/"
            })
>       response = client.post(
            f"/following/?{query_string}",
            data={"operation": "follow", "username": "jag"}
        )

tests/test_explore.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.10/site-packages/werkzeug/test.py:1134: in post
    return self.open(*args, **kw)
env/lib/python3.10/site-packages/flask/testing.py:216: in open
    return super().open(  # type: ignore
env/lib/python3.10/site-packages/werkzeug/test.py:1074: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:945: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:1231: in run_wsgi_app
    app_rv = app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2091: in __call__
    return self.wsgi_app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2076: in wsgi_app
    response = self.handle_exception(e)
env/lib/python3.10/site-packages/flask/app.py:2073: in wsgi_app
    response = self.full_dispatch_request()
env/lib/python3.10/site-packages/flask/app.py:1518: in full_dispatch_request
    rv = self.handle_user_exception(e)
env/lib/python3.10/site-packages/flask/app.py:1516: in full_dispatch_request
    rv = self.dispatch_request()
env/lib/python3.10/site-packages/flask/app.py:1502: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
insta485/views/index.py:467: in follow_unfollow
    logname = flask.session['username']
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <SecureCookieSession {'logname': 'awdeorio'}>, key = 'username'

    def __getitem__(self, key: str) -> t.Any:
        self.accessed = True
>       return super().__getitem__(key)
E       KeyError: 'username'

env/lib/python3.10/site-packages/flask/sessions.py:79: KeyError
___________________________ test_awdeorio_followers ____________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_awdeorio_followers(client):
        """Check default content at /users/awdeorio/followers/ URL."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse followers pages
        response = client.get("/users/awdeorio/followers/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        text = soup.get_text()
        text = re.sub(r"\s+", " ", text)
        links = [x.get("href") for x in soup.find_all("a")]
        srcs = [x.get("src") for x in soup.find_all('img')]
        buttons = [submit.get("name") for button in soup.find_all('form')
                   for submit in button.find_all("input") if submit]
    
        # Every page should have a header
        assert "/" in links
        assert "/explore/" in links
        assert "/users/awdeorio/" in links
    
        # Links specific to /users/awdeorio/followers/
        assert "/users/jflinn/" in links
        assert "/users/michjc/" in links
        assert "/users/jag/" not in links
    
        # Check for images: Mike, Jason, Jag
>       assert "/uploads/5ecde7677b83304132cb2871516ea50032ff7a4f.jpg" in srcs
E       AssertionError: assert '/uploads/5ecde7677b83304132cb2871516ea50032ff7a4f.jpg' in ['/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/505083b8b56c97429a728b68f31b0b2a089e511...rs/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/5ecde7677b83304132cb2871516ea50032ff7a4f.jpg']

tests/test_followers_public.py:49: AssertionError
__________________________________ test_files __________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_files(client):
        """Verify all expected files exist."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load images
        response = client.get(
            "/uploads/122a7d27ca1d7420a1072f695d9290fad4501a41.jpg"
        )
>       assert response.status_code == 200
E       assert 404 == 200
E         +404
E         -200

tests/test_followers_public.py:85: AssertionError
________________________________ test_unfollow _________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_unfollow(client):
        """Click unfollow.  Verify user is removed."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse followers page
        response = client.get("/users/awdeorio/followers/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        text = soup.get_text()
        text = re.sub(r"\s+", " ", text)
        links = [x.get("href") for x in soup.find_all("a")]
        buttons = [submit.get("name") for button in soup.find_all('form')
                   for submit in button.find_all("input") if submit]
    
        # awdeorio is following michjc and jfllinn, but not jag
        assert "not following" not in text.lower()
>       assert "unfollow" in buttons
E       AssertionError: assert 'unfollow' in []

tests/test_followers_public.py:117: AssertionError
_________________________________ test_follow __________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_follow(client):
        """Click follow.  Verify user is added."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse followers page
        response = client.get("/users/awdeorio/followers/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        text = soup.get_text()
        text = re.sub(r"\s+", " ", text)
        links = [x.get("href") for x in soup.find_all("a")]
        buttons = [submit.get("name") for button in soup.find_all('form')
                   for submit in button.find_all("input") if submit]
    
        # awdeorio is following michjc and jfllinn, but not jag
        assert "not following" not in text.lower()
>       assert "unfollow" in buttons
E       AssertionError: assert 'unfollow' in []

tests/test_followers_public.py:179: AssertionError
________________________________ test_awdeorio _________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_awdeorio(client):
        """Check default content at /users/awdeorio/following/ URL."""
        # Login
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse following page
        response = client.get("/users/awdeorio/following/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        text = soup.get_text()
        text = re.sub(r"\s+", " ", text)
        links = [x.get("href") for x in soup.find_all("a")]
        srcs = [x.get("src") for x in soup.find_all('img')]
    
        # Verify text
>       assert text.lower().count("following") == 3
E       assert 2 == 3
E         +2
E         -3

tests/test_following.py:38: AssertionError
________________________________ test_unfollow _________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_unfollow(client):
        """Click unfollow.  Verify user is removed."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        query_string = urlencode({
                "target": "/users/awdeorio/following/"
            })
>       response = client.post(
            f"/following/?{query_string}",
            data={"operation": "unfollow", "username": "jflinn"}
        )

tests/test_following.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.10/site-packages/werkzeug/test.py:1134: in post
    return self.open(*args, **kw)
env/lib/python3.10/site-packages/flask/testing.py:216: in open
    return super().open(  # type: ignore
env/lib/python3.10/site-packages/werkzeug/test.py:1074: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:945: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
env/lib/python3.10/site-packages/werkzeug/test.py:1231: in run_wsgi_app
    app_rv = app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2091: in __call__
    return self.wsgi_app(environ, start_response)
env/lib/python3.10/site-packages/flask/app.py:2076: in wsgi_app
    response = self.handle_exception(e)
env/lib/python3.10/site-packages/flask/app.py:2073: in wsgi_app
    response = self.full_dispatch_request()
env/lib/python3.10/site-packages/flask/app.py:1518: in full_dispatch_request
    rv = self.handle_user_exception(e)
env/lib/python3.10/site-packages/flask/app.py:1516: in full_dispatch_request
    rv = self.dispatch_request()
env/lib/python3.10/site-packages/flask/app.py:1502: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
insta485/views/index.py:467: in follow_unfollow
    logname = flask.session['username']
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <SecureCookieSession {'logname': 'awdeorio'}>, key = 'username'

    def __getitem__(self, key: str) -> t.Any:
        self.accessed = True
>       return super().__getitem__(key)
E       KeyError: 'username'

env/lib/python3.10/site-packages/flask/sessions.py:79: KeyError
_________________________________ test_images __________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_images(client):
        """Verify all images are present in / URL.
    
        Note: 'client' is a fixture fuction that provides a Flask test server
        interface with a clean database.  It is implemented in conftest.py and
        reused by many tests.  Docs: https://docs.pytest.org/en/latest/fixture.html
        """
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse index page
        response = client.get("/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        srcs = [x.get("src") for x in soup.find_all('img')]
    
        # Verify images present of Flinn, DeOrio, postid 1, postid 2, postid 3
>       assert "/uploads/505083b8b56c97429a728b68f31b0b2a089e5113.jpg" in srcs
E       AssertionError: assert '/uploads/505083b8b56c97429a728b68f31b0b2a089e5113.jpg' in ['/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/505083b8b56c97429a728b68f31b0b2a089e511...rs/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/9887e06812ef434d291e4936417d125cd594b38a.jpg']

tests/test_index.py:37: AssertionError
___________________________ test_login_page_content ____________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_login_page_content(client):
        """Verify links and form on /accounts/login/ page.
    
        Note: 'client' is a fixture fuction that provides a Flask test server
        interface with a clean database.  It is implemented in conftest.py and
        reused by many tests.  Docs: https://docs.pytest.org/en/latest/fixture.html
        """
        response = client.get("/accounts/login/")
>       assert response.status_code == 200
E       assert 302 == 200
E         +302
E         -200

tests/test_login_logout.py:33: AssertionError
________________________________ test_postid_1 _________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_postid_1(client):
        """Check default content at /posts/1/ URL."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse /posts/1/ page
        response = client.get("/posts/1/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        links = [x.get("href") for x in soup.find_all("a")]
        srcs = [x.get("src") for x in soup.find_all('img')]
        text = soup.get_text()
        text = re.sub(r"\s+", " ", text)
        buttons = [submit.get("name") for button in soup.find_all('form')
                   for submit in button.find_all("input") if submit]
    
        # Verify links in header are present
        assert "/" in links
        assert "/explore/" in links
        assert "/users/awdeorio/" in links
    
        # Verify no unexpected links to users are present
        assert "/users/michjc/" not in links
        assert "/users/jag/" not in links
    
        # Verify images present of Drew, postid 1
>       assert "/uploads/e1a7c5c32973862ee15173b0259e3efdb6a391af.jpg" in srcs
E       AssertionError: assert '/uploads/e1a7c5c32973862ee15173b0259e3efdb6a391af.jpg' in ['/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/e1a7c5c32973862ee15173b0259e3efdb6a391a...rs/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/122a7d27ca1d7420a1072f695d9290fad4501a41.jpg']

tests/test_post_public.py:50: AssertionError
________________________________ test_postid_2 _________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_postid_2(client):
        """Check default content at /posts/2/ URL."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse /posts/2/ page
        response = client.get("/posts/2/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        links = [x.get("href") for x in soup.find_all("a")]
        srcs = [x.get("src") for x in soup.find_all('img')]
        text = soup.get_text()
        text = re.sub(r"\s+", " ", text)
        buttons = []
        for button in soup.find_all('form'):
            for submit in button.find_all("input"):
                if submit:
                    buttons.append(submit.get("name"))
    
        # Verify links in header are present
        assert "/" in links
        assert "/explore/" in links
        assert "/users/awdeorio/" in links
    
        # Verify expected links to users are present
        assert "/users/jflinn/" in links
    
        # Verify no unexpected links to users are present
        assert "/users/michjc/" not in links
        assert "/users/jag/" not in links
    
        # Verify images present of Jason, postid 2
>       assert "/uploads/505083b8b56c97429a728b68f31b0b2a089e5113.jpg" in srcs
E       AssertionError: assert '/uploads/505083b8b56c97429a728b68f31b0b2a089e5113.jpg' in ['/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/505083b8b56c97429a728b68f31b0b2a089e511...rs/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/ad7790405c539894d25ab8dcf0b79eed3341e109.jpg']

tests/test_post_public.py:133: AssertionError
__________________________ test_duplicate_like_unlike __________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_duplicate_like_unlike(client):
        """Like and dislike post multiple times."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        response = client.get("/posts/1/")
        assert response.status_code == 200
    
        # Try to like and unlike the post twice
        query_string = urlencode({"target": "/posts/1/"})
        response = client.post(
            f"/likes/?{query_string}",
            data={"postid": "1", "operation": "like"}
        )
>       assert response.status_code == 409
E       assert 302 == 409
E         +302
E         -409

tests/test_post_public.py:285: AssertionError
_______________________________ test_delete_post _______________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_delete_post(client):
        """Delete post.  Make sure comments are gone and photo deleted."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Delete the post owned by awdeorio and redirect to user page
        response = client.post(
            "/posts/",
            data={"postid": "1", "operation": "delete"}
        )
>       assert response.status_code == 302
E       assert 404 == 302
E         +404
E         -302

tests/test_post_public.py:375: AssertionError
_______________________________ test_pycodestyle _______________________________

    def test_pycodestyle():
        """Run pycodestyle."""
        assert_no_prohibited_terms("nopep8", "noqa", "pylint")
>       subprocess.run(["pycodestyle", "setup.py", "insta485"], check=True)

tests/test_style.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (['pycodestyle', 'setup.py', 'insta485'],), kwargs = {}
process = <Popen: returncode: 1 args: ['pycodestyle', 'setup.py', 'insta485']>
stdout = None, stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['pycodestyle', 'setup.py', 'insta485']' returned non-zero exit status 1.

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/subprocess.py:524: CalledProcessError
----------------------------- Captured stdout call -----------------------------
insta485/__init__.py:5:80: E501 line too long (88 > 79 characters)
insta485/model.py:45:26: W292 no newline at end of file
insta485/views/__init__.py:2:44: W292 no newline at end of file
insta485/views/index.py:15:12: W291 trailing whitespace
insta485/views/index.py:18:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:25:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:34:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:41:21: E203 whitespace before ':'
insta485/views/index.py:41:80: E501 line too long (109 > 79 characters)
insta485/views/index.py:43:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:51:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:73:80: E501 line too long (134 > 79 characters)
insta485/views/index.py:76:22: E231 missing whitespace after ','
insta485/views/index.py:79:49: E231 missing whitespace after ','
insta485/views/index.py:87:29: E203 whitespace before ':'
insta485/views/index.py:88:28: E203 whitespace before ':'
insta485/views/index.py:89:36: E203 whitespace before ':'
insta485/views/index.py:89:80: E501 line too long (93 > 79 characters)
insta485/views/index.py:90:30: E203 whitespace before ':'
insta485/views/index.py:90:80: E501 line too long (87 > 79 characters)
insta485/views/index.py:91:32: E203 whitespace before ':'
insta485/views/index.py:91:80: E501 line too long (89 > 79 characters)
insta485/views/index.py:92:28: E203 whitespace before ':'
insta485/views/index.py:93:31: E203 whitespace before ':'
insta485/views/index.py:95:80: E501 line too long (82 > 79 characters)
insta485/views/index.py:103:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:111:80: E501 line too long (92 > 79 characters)
insta485/views/index.py:131:1: W293 blank line contains whitespace
insta485/views/index.py:133:9: E265 block comment should start with '# '
insta485/views/index.py:150:1: W293 blank line contains whitespace
insta485/views/index.py:156:80: E501 line too long (93 > 79 characters)
insta485/views/index.py:196:80: E501 line too long (109 > 79 characters)
insta485/views/index.py:219:80: E501 line too long (92 > 79 characters)
insta485/views/index.py:220:80: E501 line too long (82 > 79 characters)
insta485/views/index.py:228:1: W293 blank line contains whitespace
insta485/views/index.py:245:17: E231 missing whitespace after ','
insta485/views/index.py:258:80: E501 line too long (90 > 79 characters)
insta485/views/index.py:268:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:273:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:281:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:289:80: E501 line too long (81 > 79 characters)
insta485/views/index.py:310:80: E501 line too long (93 > 79 characters)
insta485/views/index.py:341:80: E501 line too long (125 > 79 characters)
insta485/views/index.py:364:80: E501 line too long (88 > 79 characters)
insta485/views/index.py:402:1: W293 blank line contains whitespace
insta485/views/index.py:413:50: W291 trailing whitespace
insta485/views/index.py:414:80: E501 line too long (89 > 79 characters)
insta485/views/index.py:414:90: W291 trailing whitespace
insta485/views/index.py:415:80: E501 line too long (84 > 79 characters)
insta485/views/index.py:422:1: W293 blank line contains whitespace
insta485/views/index.py:433:5: E303 too many blank lines (2)
insta485/views/index.py:452:50: W291 trailing whitespace
insta485/views/index.py:453:80: E501 line too long (89 > 79 characters)
insta485/views/index.py:453:90: W291 trailing whitespace
insta485/views/index.py:454:80: E501 line too long (85 > 79 characters)
insta485/views/index.py:462:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:470:80: E501 line too long (97 > 79 characters)
insta485/views/index.py:485:80: E501 line too long (80 > 79 characters)
insta485/views/index.py:487:80: E501 line too long (84 > 79 characters)
insta485/views/index.py:489:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:499:1: W293 blank line contains whitespace
insta485/views/index.py:508:80: E501 line too long (103 > 79 characters)
insta485/views/index.py:509:27: E203 whitespace before ':'
insta485/views/index.py:514:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:522:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:558:20: E231 missing whitespace after ','
insta485/views/index.py:559:17: W291 trailing whitespace
insta485/views/index.py:560:1: W293 blank line contains whitespace
insta485/views/index.py:569:1: W293 blank line contains whitespace
insta485/views/index.py:590:49: W291 trailing whitespace
insta485/views/index.py:598:80: E501 line too long (93 > 79 characters)
insta485/views/index.py:599:80: E501 line too long (89 > 79 characters)
_______________________________ test_pydocstyle ________________________________

    def test_pydocstyle():
        """Run pydocstyle."""
        assert_no_prohibited_terms("nopep8", "noqa", "pylint")
>       subprocess.run(["pydocstyle", "setup.py", "insta485"], check=True)

tests/test_style.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (['pydocstyle', 'setup.py', 'insta485'],), kwargs = {}
process = <Popen: returncode: 1 args: ['pydocstyle', 'setup.py', 'insta485']>
stdout = None, stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['pydocstyle', 'setup.py', 'insta485']' returned non-zero exit status 1.

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/subprocess.py:524: CalledProcessError
----------------------------- Captured stdout call -----------------------------
insta485/views/index.py:18 in public function `get_salt`:
        D103: Missing docstring in public function
insta485/views/index.py:25 in public function `hash_password`:
        D103: Missing docstring in public function
insta485/views/index.py:34 in public function `get_all_comments`:
        D103: Missing docstring in public function
insta485/views/index.py:43 in public function `get_likes`:
        D103: Missing docstring in public function
insta485/views/index.py:104 in public function `handle_account`:
        D103: Missing docstring in public function
insta485/views/index.py:231 in public function `show_explore`:
        D103: Missing docstring in public function
insta485/views/index.py:269 in public function `logout`:
        D103: Missing docstring in public function
insta485/views/index.py:274 in public function `login`:
        D103: Missing docstring in public function
insta485/views/index.py:282 in public function `show_user`:
        D103: Missing docstring in public function
insta485/views/index.py:357 in public function `show_post`:
        D103: Missing docstring in public function
insta485/views/index.py:388 in public function `show_followers`:
        D103: Missing docstring in public function
insta485/views/index.py:425 in public function `show_following`:
        D103: Missing docstring in public function
insta485/views/index.py:486 in public function `send_file`:
        D103: Missing docstring in public function
insta485/views/index.py:490 in public function `show_edit`:
        D103: Missing docstring in public function
insta485/views/index.py:515 in public function `show_password`:
        D103: Missing docstring in public function
insta485/views/index.py:523 in public function `show_delete`:
        D103: Missing docstring in public function
insta485/views/index.py:539 in public function `like`:
        D103: Missing docstring in public function
insta485/views/index.py:584 in public function `comment`:
        D103: Missing docstring in public function
_________________________________ test_pylint __________________________________

    def test_pylint():
        """Run pylint."""
        assert_no_prohibited_terms("nopep8", "noqa", "pylint")
>       subprocess.run([
            "pylint",
            "--rcfile", utils.TEST_DIR/"testdata/pylintrc",
            "--disable=cyclic-import",
            "--disable=assigning-non-slot",
            "--unsafe-load-any-extension=y",
            "setup.py",
            "insta485",
        ], check=True)

tests/test_style.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (['pylint', '--rcfile', PosixPath('/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/tests/testdata/pylintrc'), '--disable=cyclic-import', '--disable=assigning-non-slot', '--unsafe-load-any-extension=y', ...],)
kwargs = {}
process = <Popen: returncode: 28 args: ['pylint', '--rcfile', PosixPath('/Users/johnky...>
stdout = None, stderr = None, retcode = 28

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['pylint', '--rcfile', PosixPath('/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/tests/testdata/pylintrc'), '--disable=cyclic-import', '--disable=assigning-non-slot', '--unsafe-load-any-extension=y', 'setup.py', 'insta485']' returned non-zero exit status 28.

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/subprocess.py:524: CalledProcessError
----------------------------- Captured stdout call -----------------------------
************* Module insta485.model
insta485/model.py:45:0: C0304: Final newline missing (missing-final-newline)
************* Module insta485.views.index
insta485/views/index.py:133:9: W0511: TODO: implement (fixme)
insta485/views/index.py:166:9: W0511: TODO: WRONG, FIX FILE UPLOAD (fixme)
insta485/views/index.py:219:9: W0511: TODO: new hash, don't use old salt won't work, do complete password alg. from spec (fixme)
insta485/views/index.py:15:11: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:41:0: C0301: Line too long (109/100) (line-too-long)
insta485/views/index.py:73:0: C0301: Line too long (134/100) (line-too-long)
insta485/views/index.py:131:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:150:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:196:0: C0301: Line too long (109/100) (line-too-long)
insta485/views/index.py:228:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:341:0: C0301: Line too long (125/100) (line-too-long)
insta485/views/index.py:402:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:413:49: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:414:89: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:422:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:452:49: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:453:89: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:499:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:508:0: C0301: Line too long (103/100) (line-too-long)
insta485/views/index.py:559:16: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:560:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:569:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:590:48: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:18:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:25:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:34:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:43:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:57:4: R1705: Unnecessary "else" after "return" (no-else-return)
insta485/views/index.py:104:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:104:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
insta485/views/index.py:164:8: W0612: Unused variable 'cursor' (unused-variable)
insta485/views/index.py:104:0: R0912: Too many branches (19/12) (too-many-branches)
insta485/views/index.py:104:0: R0915: Too many statements (66/50) (too-many-statements)
insta485/views/index.py:231:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:269:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:274:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:276:4: R1705: Unnecessary "else" after "return" (no-else-return)
insta485/views/index.py:282:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:357:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:388:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:425:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:467:4: W0612: Unused variable 'logname' (unused-variable)
insta485/views/index.py:470:4: W0612: Unused variable 'operation' (unused-variable)
insta485/views/index.py:470:15: W0612: Unused variable 'username' (unused-variable)
insta485/views/index.py:471:4: W0612: Unused variable 'target' (unused-variable)
insta485/views/index.py:486:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:490:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:515:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:523:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:539:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:561:4: R1705: Unnecessary "elif" after "return" (no-else-return)
insta485/views/index.py:548:4: W0612: Unused variable 'post_info' (unused-variable)
insta485/views/index.py:584:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:7:0: W0611: Unused import re (unused-import)
insta485/views/index.py:8:0: W0611: Unused L imported from re (unused-import)
insta485/views/index.py:11:0: W0611: Unused empty imported from pyparsing (unused-import)
insta485/views/index.py:14:0: W0611: Unused import pdb (unused-import)
insta485/views/index.py:15:0: W0611: Unused import uuid (unused-import)
insta485/views/index.py:13:0: C0411: standard import "import sqlite3" should be placed before "import arrow" (wrong-import-order)
insta485/views/index.py:14:0: C0411: standard import "import pdb" should be placed before "import arrow" (wrong-import-order)
insta485/views/index.py:15:0: C0411: standard import "import uuid" should be placed before "import arrow" (wrong-import-order)
insta485/views/index.py:16:0: C0411: standard import "import hashlib" should be placed before "import arrow" (wrong-import-order)
************* Module insta485.views.__init__
insta485/views/__init__.py:2:0: C0304: Final newline missing (missing-final-newline)

------------------------------------------------------------------
Your code has been rated at 7.92/10 (previous run: 7.92/10, +0.00)

__________________________________ test_html ___________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_html(client):
        """Validate generated HTML5 in insta485/templates/ ."""
        # Log in as awdeorio
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Clean up
        if os.path.exists("tmp/localhost"):
            shutil.rmtree("tmp/localhost")
    
        # Render all pages and download HTML to ./tmp/localhost/
>       crawl(
            client=client,
            outputdir="tmp/localhost",
            todo=collections.deque([CrawlURL(url='/', source='/')]),
            done=set(),
        )

tests/test_style.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

client = <FlaskClient <Flask 'insta485'>>
outputdir = PosixPath('tmp/localhost')
todo = deque([CrawlURL(url='/posts/1/', source='/users/awdeorio/'), CrawlURL(url='/posts/3/', source='/users/awdeorio/'), Cra...flinn/'), CrawlURL(url='/posts/2/', source='/users/jflinn/'), CrawlURL(url='/users/michjc/', source='/posts/3/'), ...])
done = {'/', '/explore/', '/posts/1/', '/posts/2/', '/posts/3/', '/users/awdeorio/', ...}

    def crawl(client, outputdir, todo, done):
        """Recursively render every page provided by 'client', saving to file."""
        if not todo:
            return
        # Pop a URL off the head of the queue and parse it
        url_pair = todo.popleft()
        hostname = urlparse(url_pair.url).hostname
        path = urlparse(url_pair.url).path
    
        # Ignore links outside localhost
        if hostname and hostname not in ["localhost", "127.0.01"]:
            done.add(path)
            crawl(client, outputdir, todo, done)
            return
    
        # Ignore links already visited
        if path in done:
            done.add(path)
            crawl(client, outputdir, todo, done)
            return
    
        # Ignore logout route
        if "logout" in path:
            done.add(path)
            crawl(client, outputdir, todo, done)
            return
    
        # Download
        print("GET", path, "FROM", url_pair.source)
        response = client.get(path)
    
        # redirect routes should return 302 status
        redirect_routes = ["/accounts/create/"]
        if path in redirect_routes:
            assert response.status_code == 302
        else:
>           assert response.status_code == 200
E           assert 404 == 200
E             +404
E             -200

tests/test_style.py:150: AssertionError
----------------------------- Captured stdout call -----------------------------
GET / FROM /
GET /explore/ FROM /
GET /users/awdeorio/ FROM /
GET /users/jflinn/ FROM /
GET /posts/2/ FROM /
GET /posts/1/ FROM /
GET /posts/3/ FROM /
GET /users/michjc/ FROM /
GET /users/jag/ FROM /explore/
GET /users/awdeorio/followers/ FROM /users/awdeorio/
GET /users/awdeorio/following/ FROM /users/awdeorio/
GET  /accounts/edit/ FROM /users/awdeorio/
________________________________ test_awdeorio _________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_awdeorio(client):
        """Check default content at /users/awdeorio/ URL."""
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse user page
        response = client.get("/users/awdeorio/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        text = soup.get_text()
        text = re.sub(r"\s+", " ", text)
        srcs = [x.get("src") for x in soup.find_all('img')]
        links = [x.get("href") for x in soup.find_all("a")]
        buttons = [submit.get("name") for button in soup.find_all('form')
                   for submit in button.find_all("input") if submit]
    
        # Verify links in header
        assert "/" in links
        assert "/explore/" in links
        assert "/users/awdeorio/" in links
    
        # Links specific to /users/awdeorio/followers/
        assert "/users/awdeorio/followers/" in links
        assert "/users/awdeorio/following/" in links
        assert "/posts/1/" in links
        assert "/posts/3/" in links
        assert "/users/jflinn/followers/" not in links
        assert "/users/jflinn/following/" not in links
        assert "/users/michjc/followers/" not in links
        assert "/users/michjc/following/" not in links
        assert "/users/jag/followers/" not in links
        assert "/users/jag/following/" not in links
        assert "/posts/2/" not in links
        assert "/posts/4/" not in links
    
        # Verify images: post 1,2,3,4
>       assert "/uploads/122a7d27ca1d7420a1072f695d9290fad4501a41.jpg" in srcs
E       AssertionError: assert '/uploads/122a7d27ca1d7420a1072f695d9290fad4501a41.jpg' in ['/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/122a7d27ca1d7420a1072f695d9290fad4501a4...rs/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/var/uploads/9887e06812ef434d291e4936417d125cd594b38a.jpg']

tests/test_user_public.py:59: AssertionError
_________________________________ test_upload __________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_upload(client):
        """Upload a new post verify that it shows up."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse user page
        response = client.get("/users/awdeorio/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        srcs_before = [x.get("src") for x in soup.find_all('img')]
    
        # Upload a new post
        pic_path = utils.TEST_DIR/'testdata/fox.jpg'
        with pic_path.open("rb") as pic:
            response = client.post(
                "/posts/",
                data={"file": pic, "create_post": "upload new post", "operation":
                      "create"}
            )
>       assert response.status_code == 302
E       assert 404 == 302
E         +404
E         -302

tests/test_user_public.py:110: AssertionError
=========================== short test summary info ============================
FAILED tests/test_accounts_public.py::test_accounts_create - TypeError: The v...
FAILED tests/test_accounts_public.py::test_accounts_edit - AssertionError: as...
FAILED tests/test_accounts_public.py::test_accounts_delete - KeyError: 'logname'
FAILED tests/test_accounts_public.py::test_accounts_uploads_permission - asse...
FAILED tests/test_explore.py::test_awdeorio_default - AssertionError: assert ...
FAILED tests/test_explore.py::test_follow - KeyError: 'username'
FAILED tests/test_explore.py::test_empty - KeyError: 'username'
FAILED tests/test_followers_public.py::test_awdeorio_followers - AssertionErr...
FAILED tests/test_followers_public.py::test_files - assert 404 == 200
FAILED tests/test_followers_public.py::test_unfollow - AssertionError: assert...
FAILED tests/test_followers_public.py::test_follow - AssertionError: assert '...
FAILED tests/test_following.py::test_awdeorio - assert 2 == 3
FAILED tests/test_following.py::test_unfollow - KeyError: 'username'
FAILED tests/test_index.py::test_images - AssertionError: assert '/uploads/50...
FAILED tests/test_login_logout.py::test_login_page_content - assert 302 == 200
FAILED tests/test_post_public.py::test_postid_1 - AssertionError: assert '/up...
FAILED tests/test_post_public.py::test_postid_2 - AssertionError: assert '/up...
FAILED tests/test_post_public.py::test_duplicate_like_unlike - assert 302 == 409
FAILED tests/test_post_public.py::test_delete_post - assert 404 == 302
FAILED tests/test_style.py::test_pycodestyle - subprocess.CalledProcessError:...
FAILED tests/test_style.py::test_pydocstyle - subprocess.CalledProcessError: ...
FAILED tests/test_style.py::test_pylint - subprocess.CalledProcessError: Comm...
FAILED tests/test_style.py::test_html - assert 404 == 200
FAILED tests/test_user_public.py::test_awdeorio - AssertionError: assert '/up...
FAILED tests/test_user_public.py::test_upload - assert 404 == 302
======================== 25 failed, 23 passed in 16.72s ========================
