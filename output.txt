============================= test session starts ==============================
platform darwin -- Python 3.10.1, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/env/bin/python3
cachedir: .pytest_cache
rootdir: /Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside
plugins: mock-3.7.0
collecting ... collected 48 items

tests/test_accounts_public.py::test_accounts_create FAILED               [  2%]
tests/test_accounts_public.py::test_accounts_edit FAILED                 [  4%]
tests/test_accounts_public.py::test_accounts_password PASSED             [  6%]
tests/test_accounts_public.py::test_accounts_delete FAILED               [  8%]
tests/test_accounts_public.py::test_accounts_uploads_permission PASSED   [ 10%]
tests/test_database_public.py::test_sql_schema PASSED                    [ 12%]
tests/test_database_public.py::test_likeids PASSED                       [ 14%]
tests/test_database_public.py::test_posts_autoincrement PASSED           [ 16%]
tests/test_database_public.py::test_sql_data_users_posts PASSED          [ 18%]
tests/test_explore.py::test_awdeorio_default PASSED                      [ 20%]
tests/test_explore.py::test_follow PASSED                                [ 22%]
tests/test_explore.py::test_empty PASSED                                 [ 25%]
tests/test_followers_public.py::test_awdeorio_followers PASSED           [ 27%]
tests/test_followers_public.py::test_files PASSED                        [ 29%]
tests/test_followers_public.py::test_unfollow PASSED                     [ 31%]
tests/test_followers_public.py::test_follow PASSED                       [ 33%]
tests/test_following.py::test_awdeorio PASSED                            [ 35%]
tests/test_following.py::test_unfollow PASSED                            [ 37%]
tests/test_following.py::test_not_following PASSED                       [ 39%]
tests/test_index.py::test_images PASSED                                  [ 41%]
tests/test_index.py::test_links PASSED                                   [ 43%]
tests/test_index.py::test_likes PASSED                                   [ 45%]
tests/test_index.py::test_timestamps PASSED                              [ 47%]
tests/test_index.py::test_comments PASSED                                [ 50%]
tests/test_login_logout.py::test_index_redirect PASSED                   [ 52%]
tests/test_login_logout.py::test_login_page_content PASSED               [ 54%]
tests/test_login_logout.py::test_login PASSED                            [ 56%]
tests/test_login_logout.py::test_logout PASSED                           [ 58%]
tests/test_post_public.py::test_postid_1 PASSED                          [ 60%]
tests/test_post_public.py::test_postid_2 PASSED                          [ 62%]
tests/test_post_public.py::test_zero_likes_english PASSED                [ 64%]
tests/test_post_public.py::test_delete_comment PASSED                    [ 66%]
tests/test_post_public.py::test_like_unlike PASSED                       [ 68%]
tests/test_post_public.py::test_duplicate_like_unlike PASSED             [ 70%]
tests/test_post_public.py::test_comment PASSED                           [ 72%]
tests/test_post_public.py::test_delete_post FAILED                       [ 75%]
tests/test_scripts.py::test_insta485db_destroy PASSED                    [ 77%]
tests/test_scripts.py::test_insta485db_create PASSED                     [ 79%]
tests/test_scripts.py::test_insta485db_reset PASSED                      [ 81%]
tests/test_scripts.py::test_insta485db_dump PASSED                       [ 83%]
tests/test_scripts.py::test_insta485run PASSED                           [ 85%]
tests/test_scripts.py::test_insta485test PASSED                          [ 87%]
tests/test_style.py::test_pycodestyle FAILED                             [ 89%]
tests/test_style.py::test_pydocstyle FAILED                              [ 91%]
tests/test_style.py::test_pylint FAILED                                  [ 93%]
tests/test_style.py::test_html FAILED                                    [ 95%]
tests/test_user_public.py::test_awdeorio FAILED                          [ 97%]
tests/test_user_public.py::test_upload FAILED                            [100%]

=================================== FAILURES ===================================
_____________________________ test_accounts_create _____________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_accounts_create(client):
        """Create an account and verify that we've got a new empty user.
    
        Note: 'client' is a fixture fuction that provides a Flask test server
        interface with a clean database.  It is implemented in conftest.py and
        reused by many tests.  Docs: https://docs.pytest.org/en/latest/fixture.html
        """
        # Connect to the database
        connection = sqlite3.connect("var/insta485.sqlite3")
        connection.execute("PRAGMA foreign_keys = ON")
    
        # Number of posts and users before adding a user
        cur = connection.execute("SELECT COUNT(*) from users")
        num_users_before = cur.fetchone()[0]
        cur = connection.execute("SELECT COUNT(*) from posts")
        num_posts_before = cur.fetchone()[0]
    
        # Add a user
        avatar_path = utils.TEST_DIR/"testdata/fox.jpg"
        with avatar_path.open('rb') as avatar:
            query_string = urlencode({"target": "/"})
            response = client.post(
                f"/accounts/?{query_string}",
                data={
                    "username": "fakeuser", "fullname": "Fake User",
                    "email": "fakeuser@umich.edu",
                    "password": "password",
                    "file": avatar,
                    "operation": "create"
                }
            )
    
        assert response.status_code == 302
        urlpath = urlparse(response.location).path
>       assert urlpath == "/"
E       AssertionError: assert '/accounts/login/' == '/'
E         - /
E         + /accounts/login/

tests/test_accounts_public.py:48: AssertionError
______________________________ test_accounts_edit ______________________________

client = <FlaskClient <Flask 'insta485'>>
mocker = <pytest_mock.plugin.MockerFixture object at 0x10a483be0>

    def test_accounts_edit(client, mocker):
        """Change name, email and photo.
    
        Note: 'client' is a fixture fuction that provides a Flask test server
        interface with a clean database.  It is implemented in conftest.py and
        reused by many tests.  Docs: https://docs.pytest.org/en/latest/fixture.html
    
        Note: 'mocker' is a fixture function provided the the pytest-mock package.
        This fixture lets us override a library function with a temporary fake
        function that returns a hardcoded value while testing.
        """
        # Fake the uuid4() function to return a hardcoded UUID.  We need a
        # predictable value for testing, not a randomly generated value.
        mocker.patch(
            "uuid.uuid4",
            return_value=uuid.UUID("00000000000000000000000000000000"),
        )
    
        # Log in
        response = client.post(
            "/accounts/",
            data={"username": "awdeorio",
                  "password": "password",
                  "operation": "login"},
        )
        assert response.status_code == 302
    
        # Change name, email and photo
        avatar_path = utils.TEST_DIR/"testdata/fox.jpg"
        with avatar_path.open('rb') as avatar:
            query_string = urlencode({"target": "/accounts/edit/"})
            response = client.post(
                f"/accounts/?{query_string}",
                data={
                    "fullname": "New Name",
                    "email": "newemail@umich.edu",
                    "file": avatar,
                    "update": "submit",
                    "operation": "edit_account"
                },
            )
    
        assert response.status_code == 302
        urlpath = urlparse(response.location).path
        assert urlpath == "/accounts/edit/"
    
        # HACK: Work around to ensure database commit.  The post request above
        # modifies the database.  The modification won't be written until the
        # sqlite3 commit() function is called.  The commit() function is called by
        # model.py::close_db().  The close_db() function runs automatically at the
        # end of a request.  For testing, we temporarily keep the last request
        # open.  This allows us to do things like inspecting the request object.
        # However, in this test, the temporarily open request prevents the database
        # from being written out.
        #
        # The work around is to make a dummy request, which causes the previous
        # request to close and commit() is called automatically.
        #
        # Flask docs:
        # https://flask.palletsprojects.com/en/1.1.x/reqcontext/#teardown-callbacks
        response = client.get("/")
        assert response.status_code == 200
    
        # Look up new users in the database
        connection = sqlite3.connect("var/insta485.sqlite3")
        connection.execute("PRAGMA foreign_keys = ON")
        cur = connection.execute(
            "SELECT username, fullname, email, filename "
            "FROM users WHERE username='awdeorio'"
        )
        users = cur.fetchall()
    
        # Verify new database entry
>       assert users == [(
            "awdeorio",
            "New Name",
            "newemail@umich.edu",
            "00000000000000000000000000000000.jpg",
        )]
E       AssertionError: assert [('awdeorio',\n  'New Name',\n  'newemail@umich.edu',\n  'e1a7c5c32973862ee15173b0259e3efdb6a391af.jpg')] == [('awdeorio',\n  'New Name',\n  'newemail@umich.edu',\n  '00000000000000000000000000000000.jpg')]
E         At index 0 diff: ('awdeorio', 'New Name', 'newemail@umich.edu', 'e1a7c5c32973862ee15173b0259e3efdb6a391af.jpg') != ('awdeorio', 'New Name', 'newemail@umich.edu', '00000000000000000000000000000000.jpg')
E         Full diff:
E           [
E            ('awdeorio',
E             'New Name',
E             'newemail@umich.edu',
E         -   '00000000000000000000000000000000.jpg'),
E         +   'e1a7c5c32973862ee15173b0259e3efdb6a391af.jpg'),
E           ]

tests/test_accounts_public.py:151: AssertionError
_____________________________ test_accounts_delete _____________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_accounts_delete(client):
        """Delete account and verify that everything is gone.
    
        Note: 'client' is a fixture fuction that provides a Flask test server
        interface with a clean database.  It is implemented in conftest.py and
        reused by many tests.  Docs: https://docs.pytest.org/en/latest/fixture.html
        """
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Delete account
        query_string = urlencode({"target": "/accounts/create/"})
        response = client.post(
            f"/accounts/?{query_string}",
            data={
                "delete": "confirm delete account",
                "operation": "delete"
            }
        )
        assert response.status_code == 302
        urlpath = urlparse(response.location).path
        assert urlpath == "/accounts/create/"
    
        # User can no longer access post 1, should be redirected to login
        response = client.get("/posts/1/")
        assert response.status_code == 302
        urlpath = urlparse(response.location).path
        assert urlpath == "/accounts/login/"
    
        # User can no longer access post 3, should be redirected to login
        response = client.get("/posts/3/")
        assert response.status_code == 302
        urlpath = urlparse(response.location).path
        assert urlpath == "/accounts/login/"
    
        # Log in should fail
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 403
    
        # User pages should be gone
        response = client.get("/users/awdeorio/")
        assert response.status_code == 302
        response = client.get("/users/awdeorio/following/")
        assert response.status_code == 302
        response = client.get("/users/awdeorio/followers/")
        assert response.status_code == 302
    
        # Log in as user jag
        response = client.post(
            "/accounts/",
            data={
                "username": "jag",
                "password": "password",
                "operation": "login"
            },
        )
        # Verify awdeorio's images were deleted
        response = client.get(
            "/uploads/122a7d27ca1d7420a1072f695d9290fad4501a41.jpg"
        )
>       assert response.status_code == 404
E       assert 200 == 404
E         +200
E         -404

tests/test_accounts_public.py:293: AssertionError
_______________________________ test_delete_post _______________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_delete_post(client):
        """Delete post.  Make sure comments are gone and photo deleted."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Delete the post owned by awdeorio and redirect to user page
        response = client.post(
            "/posts/",
            data={"postid": "1", "operation": "delete"}
        )
>       assert response.status_code == 302
E       assert 404 == 302
E         +404
E         -302

tests/test_post_public.py:375: AssertionError
_______________________________ test_pycodestyle _______________________________

    def test_pycodestyle():
        """Run pycodestyle."""
        assert_no_prohibited_terms("nopep8", "noqa", "pylint")
>       subprocess.run(["pycodestyle", "setup.py", "insta485"], check=True)

tests/test_style.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (['pycodestyle', 'setup.py', 'insta485'],), kwargs = {}
process = <Popen: returncode: 1 args: ['pycodestyle', 'setup.py', 'insta485']>
stdout = None, stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['pycodestyle', 'setup.py', 'insta485']' returned non-zero exit status 1.

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/subprocess.py:524: CalledProcessError
----------------------------- Captured stdout call -----------------------------
insta485/__init__.py:5:80: E501 line too long (88 > 79 characters)
insta485/model.py:45:26: W292 no newline at end of file
insta485/views/__init__.py:2:44: W292 no newline at end of file
insta485/views/index.py:16:12: W291 trailing whitespace
insta485/views/index.py:20:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:27:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:36:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:43:21: E203 whitespace before ':'
insta485/views/index.py:43:80: E501 line too long (109 > 79 characters)
insta485/views/index.py:45:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:55:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:77:80: E501 line too long (134 > 79 characters)
insta485/views/index.py:80:22: E231 missing whitespace after ','
insta485/views/index.py:83:64: E231 missing whitespace after ','
insta485/views/index.py:86:29: E203 whitespace before ':'
insta485/views/index.py:87:28: E203 whitespace before ':'
insta485/views/index.py:88:36: E203 whitespace before ':'
insta485/views/index.py:89:30: E203 whitespace before ':'
insta485/views/index.py:90:32: E203 whitespace before ':'
insta485/views/index.py:90:80: E501 line too long (89 > 79 characters)
insta485/views/index.py:91:28: E203 whitespace before ':'
insta485/views/index.py:92:31: E203 whitespace before ':'
insta485/views/index.py:95:80: E501 line too long (82 > 79 characters)
insta485/views/index.py:103:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:111:80: E501 line too long (92 > 79 characters)
insta485/views/index.py:134:1: W293 blank line contains whitespace
insta485/views/index.py:141:80: E501 line too long (99 > 79 characters)
insta485/views/index.py:142:80: E501 line too long (93 > 79 characters)
insta485/views/index.py:162:35: W291 trailing whitespace
insta485/views/index.py:163:80: E501 line too long (81 > 79 characters)
insta485/views/index.py:164:80: E501 line too long (86 > 79 characters)
insta485/views/index.py:181:1: W293 blank line contains whitespace
insta485/views/index.py:183:5: E303 too many blank lines (2)
insta485/views/index.py:208:1: W293 blank line contains whitespace
insta485/views/index.py:214:80: E501 line too long (93 > 79 characters)
insta485/views/index.py:263:80: E501 line too long (109 > 79 characters)
insta485/views/index.py:286:80: E501 line too long (92 > 79 characters)
insta485/views/index.py:287:80: E501 line too long (82 > 79 characters)
insta485/views/index.py:296:1: W293 blank line contains whitespace
insta485/views/index.py:313:17: E231 missing whitespace after ','
insta485/views/index.py:338:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:343:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:351:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:359:80: E501 line too long (81 > 79 characters)
insta485/views/index.py:380:80: E501 line too long (93 > 79 characters)
insta485/views/index.py:411:80: E501 line too long (88 > 79 characters)
insta485/views/index.py:435:80: E501 line too long (88 > 79 characters)
insta485/views/index.py:474:1: W293 blank line contains whitespace
insta485/views/index.py:485:50: W291 trailing whitespace
insta485/views/index.py:486:53: W291 trailing whitespace
insta485/views/index.py:487:80: E501 line too long (84 > 79 characters)
insta485/views/index.py:496:1: W293 blank line contains whitespace
insta485/views/index.py:507:5: E303 too many blank lines (2)
insta485/views/index.py:526:50: W291 trailing whitespace
insta485/views/index.py:527:53: W291 trailing whitespace
insta485/views/index.py:528:80: E501 line too long (85 > 79 characters)
insta485/views/index.py:537:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:546:80: E501 line too long (97 > 79 characters)
insta485/views/index.py:583:80: E501 line too long (84 > 79 characters)
insta485/views/index.py:585:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:595:1: W293 blank line contains whitespace
insta485/views/index.py:605:27: E203 whitespace before ':'
insta485/views/index.py:611:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:619:1: E302 expected 2 blank lines, found 1
insta485/views/index.py:650:20: E231 missing whitespace after ','
insta485/views/index.py:651:17: W291 trailing whitespace
insta485/views/index.py:652:1: W293 blank line contains whitespace
insta485/views/index.py:686:49: W291 trailing whitespace
insta485/views/index.py:694:80: E501 line too long (93 > 79 characters)
insta485/views/index.py:695:80: E501 line too long (89 > 79 characters)
_______________________________ test_pydocstyle ________________________________

    def test_pydocstyle():
        """Run pydocstyle."""
        assert_no_prohibited_terms("nopep8", "noqa", "pylint")
>       subprocess.run(["pydocstyle", "setup.py", "insta485"], check=True)

tests/test_style.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (['pydocstyle', 'setup.py', 'insta485'],), kwargs = {}
process = <Popen: returncode: 1 args: ['pydocstyle', 'setup.py', 'insta485']>
stdout = None, stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['pydocstyle', 'setup.py', 'insta485']' returned non-zero exit status 1.

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/subprocess.py:524: CalledProcessError
----------------------------- Captured stdout call -----------------------------
insta485/views/index.py:20 in public function `get_salt`:
        D103: Missing docstring in public function
insta485/views/index.py:27 in public function `hash_password`:
        D103: Missing docstring in public function
insta485/views/index.py:36 in public function `get_all_comments`:
        D103: Missing docstring in public function
insta485/views/index.py:45 in public function `get_likes`:
        D103: Missing docstring in public function
insta485/views/index.py:104 in public function `handle_account`:
        D103: Missing docstring in public function
insta485/views/index.py:299 in public function `show_explore`:
        D103: Missing docstring in public function
insta485/views/index.py:339 in public function `logout`:
        D103: Missing docstring in public function
insta485/views/index.py:344 in public function `login`:
        D103: Missing docstring in public function
insta485/views/index.py:352 in public function `show_user`:
        D103: Missing docstring in public function
insta485/views/index.py:428 in public function `show_post`:
        D103: Missing docstring in public function
insta485/views/index.py:460 in public function `show_followers`:
        D103: Missing docstring in public function
insta485/views/index.py:499 in public function `show_following`:
        D103: Missing docstring in public function
insta485/views/index.py:580 in public function `send_file`:
        D103: Missing docstring in public function
insta485/views/index.py:586 in public function `show_edit`:
        D103: Missing docstring in public function
insta485/views/index.py:612 in public function `show_password`:
        D103: Missing docstring in public function
insta485/views/index.py:620 in public function `show_delete`:
        D103: Missing docstring in public function
insta485/views/index.py:636 in public function `like`:
        D103: Missing docstring in public function
insta485/views/index.py:680 in public function `comment`:
        D103: Missing docstring in public function
_________________________________ test_pylint __________________________________

    def test_pylint():
        """Run pylint."""
        assert_no_prohibited_terms("nopep8", "noqa", "pylint")
>       subprocess.run([
            "pylint",
            "--rcfile", utils.TEST_DIR/"testdata/pylintrc",
            "--disable=cyclic-import",
            "--disable=assigning-non-slot",
            "--unsafe-load-any-extension=y",
            "setup.py",
            "insta485",
        ], check=True)

tests/test_style.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (['pylint', '--rcfile', PosixPath('/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/tests/testdata/pylintrc'), '--disable=cyclic-import', '--disable=assigning-non-slot', '--unsafe-load-any-extension=y', ...],)
kwargs = {}
process = <Popen: returncode: 28 args: ['pylint', '--rcfile', PosixPath('/Users/johnky...>
stdout = None, stderr = None, retcode = 28

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['pylint', '--rcfile', PosixPath('/Users/johnkyle/Desktop/Michigan/EECS/485/p2-insta485-serverside/tests/testdata/pylintrc'), '--disable=cyclic-import', '--disable=assigning-non-slot', '--unsafe-load-any-extension=y', 'setup.py', 'insta485']' returned non-zero exit status 28.

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/subprocess.py:524: CalledProcessError
----------------------------- Captured stdout call -----------------------------
************* Module insta485.model
insta485/model.py:45:0: C0304: Final newline missing (missing-final-newline)
************* Module insta485.views.index
insta485/views/index.py:286:9: W0511: TODO: new hash, don't use old salt won't work, do complete password alg. from spec (fixme)
insta485/views/index.py:16:11: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:43:0: C0301: Line too long (109/100) (line-too-long)
insta485/views/index.py:77:0: C0301: Line too long (134/100) (line-too-long)
insta485/views/index.py:134:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:162:34: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:181:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:208:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:263:0: C0301: Line too long (109/100) (line-too-long)
insta485/views/index.py:296:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:474:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:485:49: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:486:52: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:496:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:526:49: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:527:52: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:595:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:651:16: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:652:0: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:686:48: C0303: Trailing whitespace (trailing-whitespace)
insta485/views/index.py:20:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:27:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:36:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:45:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:61:4: R1705: Unnecessary "else" after "return" (no-else-return)
insta485/views/index.py:104:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:104:0: R0914: Too many local variables (24/15) (too-many-locals)
insta485/views/index.py:129:8: R1705: Unnecessary "else" after "return" (no-else-return)
insta485/views/index.py:104:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
insta485/views/index.py:222:8: W0612: Unused variable 'cursor' (unused-variable)
insta485/views/index.py:104:0: R0911: Too many return statements (19/6) (too-many-return-statements)
insta485/views/index.py:104:0: R0912: Too many branches (24/12) (too-many-branches)
insta485/views/index.py:104:0: R0915: Too many statements (87/50) (too-many-statements)
insta485/views/index.py:299:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:339:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:344:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:346:4: R1705: Unnecessary "else" after "return" (no-else-return)
insta485/views/index.py:352:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:428:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:460:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:499:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:556:8: R1705: Unnecessary "else" after "return" (no-else-return)
insta485/views/index.py:567:8: R1705: Unnecessary "else" after "return" (no-else-return)
insta485/views/index.py:580:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:586:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:612:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:620:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:636:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:655:8: R1705: Unnecessary "else" after "return" (no-else-return)
insta485/views/index.py:667:8: R1705: Unnecessary "else" after "return" (no-else-return)
insta485/views/index.py:636:0: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
insta485/views/index.py:680:0: C0116: Missing function or method docstring (missing-function-docstring)
insta485/views/index.py:7:0: W0611: Unused import profile (unused-import)
insta485/views/index.py:8:0: W0611: Unused import re (unused-import)
insta485/views/index.py:9:0: W0611: Unused L imported from re (unused-import)
insta485/views/index.py:12:0: W0611: Unused empty imported from pyparsing (unused-import)
insta485/views/index.py:15:0: W0611: Unused import pdb (unused-import)
insta485/views/index.py:14:0: C0411: standard import "import sqlite3" should be placed before "import arrow" (wrong-import-order)
insta485/views/index.py:15:0: C0411: standard import "import pdb" should be placed before "import arrow" (wrong-import-order)
insta485/views/index.py:16:0: C0411: standard import "import uuid" should be placed before "import arrow" (wrong-import-order)
insta485/views/index.py:17:0: C0411: standard import "import hashlib" should be placed before "import arrow" (wrong-import-order)
insta485/views/index.py:18:0: C0411: standard import "import pathlib" should be placed before "import arrow" (wrong-import-order)
************* Module insta485.views.__init__
insta485/views/__init__.py:2:0: C0304: Final newline missing (missing-final-newline)

------------------------------------------------------------------
Your code has been rated at 8.30/10 (previous run: 8.30/10, +0.00)

__________________________________ test_html ___________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_html(client):
        """Validate generated HTML5 in insta485/templates/ ."""
        # Log in as awdeorio
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Clean up
        if os.path.exists("tmp/localhost"):
            shutil.rmtree("tmp/localhost")
    
        # Render all pages and download HTML to ./tmp/localhost/
>       crawl(
            client=client,
            outputdir="tmp/localhost",
            todo=collections.deque([CrawlURL(url='/', source='/')]),
            done=set(),
        )

tests/test_style.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:132: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
tests/test_style.py:174: in crawl
    crawl(client, outputdir, todo, done)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

client = <FlaskClient <Flask 'insta485'>>
outputdir = PosixPath('tmp/localhost')
todo = deque([CrawlURL(url='/posts/1/', source='/users/awdeorio/'), CrawlURL(url='/posts/3/', source='/users/awdeorio/'), Cra...flinn/'), CrawlURL(url='/posts/2/', source='/users/jflinn/'), CrawlURL(url='/users/michjc/', source='/posts/3/'), ...])
done = {'/', '/explore/', '/posts/1/', '/posts/2/', '/posts/3/', '/users/awdeorio/', ...}

    def crawl(client, outputdir, todo, done):
        """Recursively render every page provided by 'client', saving to file."""
        if not todo:
            return
        # Pop a URL off the head of the queue and parse it
        url_pair = todo.popleft()
        hostname = urlparse(url_pair.url).hostname
        path = urlparse(url_pair.url).path
    
        # Ignore links outside localhost
        if hostname and hostname not in ["localhost", "127.0.01"]:
            done.add(path)
            crawl(client, outputdir, todo, done)
            return
    
        # Ignore links already visited
        if path in done:
            done.add(path)
            crawl(client, outputdir, todo, done)
            return
    
        # Ignore logout route
        if "logout" in path:
            done.add(path)
            crawl(client, outputdir, todo, done)
            return
    
        # Download
        print("GET", path, "FROM", url_pair.source)
        response = client.get(path)
    
        # redirect routes should return 302 status
        redirect_routes = ["/accounts/create/"]
        if path in redirect_routes:
            assert response.status_code == 302
        else:
>           assert response.status_code == 200
E           assert 404 == 200
E             +404
E             -200

tests/test_style.py:150: AssertionError
----------------------------- Captured stdout call -----------------------------
GET / FROM /
GET /explore/ FROM /
GET /users/awdeorio/ FROM /
GET /users/jflinn/ FROM /
GET /posts/2/ FROM /
GET /posts/1/ FROM /
GET /posts/3/ FROM /
GET /users/michjc/ FROM /
GET /users/jag/ FROM /explore/
GET /users/awdeorio/followers/ FROM /users/awdeorio/
GET /users/awdeorio/following/ FROM /users/awdeorio/
GET  /accounts/edit/ FROM /users/awdeorio/
________________________________ test_awdeorio _________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_awdeorio(client):
        """Check default content at /users/awdeorio/ URL."""
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse user page
        response = client.get("/users/awdeorio/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        text = soup.get_text()
        text = re.sub(r"\s+", " ", text)
        srcs = [x.get("src") for x in soup.find_all('img')]
        links = [x.get("href") for x in soup.find_all("a")]
        buttons = [submit.get("name") for button in soup.find_all('form')
                   for submit in button.find_all("input") if submit]
    
        # Verify links in header
        assert "/" in links
        assert "/explore/" in links
        assert "/users/awdeorio/" in links
    
        # Links specific to /users/awdeorio/followers/
        assert "/users/awdeorio/followers/" in links
        assert "/users/awdeorio/following/" in links
        assert "/posts/1/" in links
        assert "/posts/3/" in links
        assert "/users/jflinn/followers/" not in links
        assert "/users/jflinn/following/" not in links
        assert "/users/michjc/followers/" not in links
        assert "/users/michjc/following/" not in links
        assert "/users/jag/followers/" not in links
        assert "/users/jag/following/" not in links
        assert "/posts/2/" not in links
        assert "/posts/4/" not in links
    
        # Verify images: post 1,2,3,4
        assert "/uploads/122a7d27ca1d7420a1072f695d9290fad4501a41.jpg" in srcs
        assert "/uploads/ad7790405c539894d25ab8dcf0b79eed3341e109.jpg" not in srcs
        assert "/uploads/9887e06812ef434d291e4936417d125cd594b38a.jpg" in srcs
        assert "/uploads/2ec7cf8ae158b3b1f40065abfb33e81143707842.jpg" not in srcs
    
        # Verify text
        assert "2 posts" in text
        assert "2 followers" in text.lower()
        assert "2 following" in text.lower()
        assert "Andrew DeOrio" in text
        assert "Edit profile" in text
        assert "not following" not in text.lower()
        assert "login" not in text
        assert text.count("awdeorio") == 2
        assert text.lower().count("following") == 1
    
        # Verify buttons
>       assert "file" in buttons
E       AssertionError: assert 'file' in ['logout']

tests/test_user_public.py:76: AssertionError
_________________________________ test_upload __________________________________

client = <FlaskClient <Flask 'insta485'>>

    def test_upload(client):
        """Upload a new post verify that it shows up."""
        # Log in
        response = client.post(
            "/accounts/",
            data={
                "username": "awdeorio",
                "password": "password",
                "operation": "login"
            },
        )
        assert response.status_code == 302
    
        # Load and parse user page
        response = client.get("/users/awdeorio/")
        assert response.status_code == 200
        soup = bs4.BeautifulSoup(response.data, "html.parser")
        srcs_before = [x.get("src") for x in soup.find_all('img')]
    
        # Upload a new post
        pic_path = utils.TEST_DIR/'testdata/fox.jpg'
        with pic_path.open("rb") as pic:
            response = client.post(
                "/posts/",
                data={"file": pic, "create_post": "upload new post", "operation":
                      "create"}
            )
>       assert response.status_code == 302
E       assert 404 == 302
E         +404
E         -302

tests/test_user_public.py:110: AssertionError
=========================== short test summary info ============================
FAILED tests/test_accounts_public.py::test_accounts_create - AssertionError: ...
FAILED tests/test_accounts_public.py::test_accounts_edit - AssertionError: as...
FAILED tests/test_accounts_public.py::test_accounts_delete - assert 200 == 404
FAILED tests/test_post_public.py::test_delete_post - assert 404 == 302
FAILED tests/test_style.py::test_pycodestyle - subprocess.CalledProcessError:...
FAILED tests/test_style.py::test_pydocstyle - subprocess.CalledProcessError: ...
FAILED tests/test_style.py::test_pylint - subprocess.CalledProcessError: Comm...
FAILED tests/test_style.py::test_html - assert 404 == 200
FAILED tests/test_user_public.py::test_awdeorio - AssertionError: assert 'fil...
FAILED tests/test_user_public.py::test_upload - assert 404 == 302
======================== 10 failed, 38 passed in 13.26s ========================
